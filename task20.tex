\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}


\usepackage[utf8]{inputenc}
\usepackage[english,russian,ukrainian]{babel}

\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\date{}


\usepackage{enumitem}
\makeatletter
\newcommand{\xslalph}[1]{\expandafter\@xslalph\csname c@#1\endcsname}
\newcommand{\@xslalph}[1]{%
    \ifcase#1\or а\or б\or в\or г\or д\or e\or є\or ж\or з\or i%
    \or й\or к\or л\or м\or н\or о\or п\or р\or с\or т%
    \or у\or ф\or х\or ц\or ч\or ш\or ю\or я\or аа\or бб\or вв%
    \else\@ctrerr\fi%
}
\AddEnumerateCounter{\xslalph}{\@xslalph}{m}
\makeatother


\begin{document}


\newpage
\subsection{12. Стандартна бібліотека С++. Асоціативні контейнери.}
\setcounter{subsection}{1}


\section{Контрольні запитання:}
\begin{itemize}
\item
Які типи ітераторів існують в STL? Які з них визначені для вектору? Які
до списку? Які для множини?
\item
Які асоціативні контейнери існують в C++? Що додає приставка multi до
назви контейнера?
\item
Для яких стандартних класів-шаблонів не визначений метод push\_back()?
Чому? Як в ці класи додаються елементи?
\item
Для яких стандартних класів-шаблонів не визначений метод push\_back()?
Чому? Як в ці класи додаються елементи?
\item
Як визначити кількість елементів будь-якого контейнеру?
\item
Які коректні шляхи ітерації по вектору? Мультивідображенню? Будь-якому
контейнеру?
\item
Як коректно пройти по всім елементам відображення?
\end{itemize}

\section{Завдання для аудиторної роботи:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  Заданий файл з текстом англійською мовою. Виділити все різні слова.
  Для кожного слова підрахувати частоту його входження. Слова, що
  відрізняються регістром літер, вважати різними. Використовувати Map.

\item
  З використанням Set виконати попарне підсумовування довільного
  кінцевого ряду чисел за такими правилами: на першому етапі
  підсумовуються попарно сусідні числа, на другому етапі підсумовуються
  результати першого етапу і т. д. до тих пір, поки не залишиться одне
  число.
\item
  У файлі записані координати точок на площині задані парою цілих чисел.
  Точки записані в форматі : ( х1 , х2 ) (х1 , х2) , \ldots{} - саме
  так через коми та дужки. Створити файл, в якому будуть записані
  координати всіх відрізків з точок цього файлу, при цьому ці відрізки
  відсортовані за зростанням довжини.

\item
  Нехай значення функції $f(n)$ -- кількість літер у письмовому
  представленні числа $n$ ($f(1)=4$ ("один"), $f(3)=3$("три"), $f(42)=8$
  ("сорок два"), $f(2001)=13$ ("дві тисячі один")). Знайдіть всі числа до
  10000, для яких $f(n) = n$. (Вказівка: Використовуйте
  відображення (словник) для зберігання кількості літер у представленні
  цифри)

\end{enumerate}

\section{Завдання для самостійної роботи:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{4}
\item
  На площині задано N точок. Вивести в файл описи всіх прямих, які
  проходять більш ніж через одну точку із заданих. Для кожної прямий
  вказати, через скільки точок вона проходить. Використовувати клас
  multimap.
\item
  На площині задано N відрізків. Знайти точку перетину двох відрізків,
  що має мінімальну абсцису. Використовувати клас map.
\item
  Відредагувати задане речення, видаляючи з нього ті слова, які
  зустрічаються в реченні задану кількість разів.
\item
  На клітковому аркуші паперу зафарбована частина клітин. Виділити все
  різні фігури, які утворилися при цьому. Фігурою вважається набір
  зафарбованих клітин, які сусідні один з одного при руху в чотирьох
  напрямах. Дві фігури є різними, якщо їх не можна сумістити поворотом
  на кут, кратний 90 градусам, і паралельним зсувом. Використовуйте
  клас multiset.


\item
  Напишіть програму, яка знаходить усі спільні слова між двома вхідними
  файлами, використовуючи set\_intersection (). Змініть його, щоб
  показати слова, які не є спільними, за допомогою
  set\_symmetric\_difference ().

\item
З бінарного файлу зчитати вектор V0, ціле число $N > 0$ і набір векторів
V1, ..., VN.  Знайти кількість векторів VI,
I = 1, ..., N, в яких містяться всі елементи вектору V0 (з урахуванням повторень). 
Використати алгоритм include.

\item
З консолі введений рядок та вектор символів V. 
Знайдіть усі різні числа, які одночасно входять
і в першу, і в другу половині вектору, і записати їх 
у текстовому файлі з заданим ім'ям у порядку заданому вектором, додаючи
після кожного числа символ пробілу (використати set\_intersection).
\item
Даний рядок name і вектор V з парною кількістю цілих елементів.
 Знайдіть усі різні числа, які входять у другу половину
вектору та при цьому відсутні в першій половині. Записати 
ці числа в текстовому файлі з ім'ям name за зростанням,
виводиться кожне число на новому рядку. Використовувати алгоритм set\_difference.
\item
Ввести з консолі вектори рядків V1 і V2. Знайти всі числа (з урахуванням повторень),
 які входять хоча б в один із вихідних векторів, і вивести їх
в порядку незростання; при цьому, якщо, наприклад, деякий рядок
входить в один із векторів 3 рази, а в іншій 5 разів, то його потрібно вивести 5 разів.
Використовувати алгоритм set\_union.
\item
Ввести з текстового файлу вектор V, що містить не менше трьох різних чисел.
Виведіть усі його різні елементи, крім максимального та мінімального, 
в порядку спадання за допомогою допоміжної множини та без неї.
\item
  Дан текстовий файл з ім'ям NameT. Підрахувати число повторень в ньому
  малих латинських літер ('a' - 'z') і створити файл з ім'ям NameS,
  рядки якого мають вигляд: "\textless{}літера\textgreater{} -
  \textless{} число повторень даної літери\textgreater{}". Літери,
  відсутні в тексті, в файл не включати. Рядки впорядкувати за спаданням
  кількості повторень літер, а при однаковій кількості повторень -- по
  зростанню кодів літер.

\item
Вввести вектор V, елементи якого є англійськими словами. Визначити суммарну довжину
слов, що починається з однієї і тієї же літери (без урахування рагістру),
 і вивести всі різні літери, з яких починаються елементи вектору V, разом із сумарною кількості цих елементів (у алфавітному порядку букв); довжину виводити зразу 
після відповідної літери. Використовувати допоміжне відображення M, ключі якого є початковими 
літерами елементів вектору V, а значення - сумарна кількість цих елементів. 
При заповненні відображення М не використовувати умовні конструкції.

\item
Ввести вектор цілих чисел V. Виконати групування елементів вектору V,
 використовуючи у якості ключу груп останню (тобто праву) 
цифру елементу: в одній групі повинні входити всі елементи V,
що закінчуються однією цифрою (згруповані 
елементи повинні розташовуватися в тому же порядку, в якому вони
доступні у векторі). Представити результат групування у вигляді відображення M, 
ключі яких є ключами групування, а значення - вектори, що містять згруповані
елементи (таким чином, відображення М повинно мати тип
map <int, vector <int>>). Вивести отримане відображення (для кожного
елементу відображення M спочатку вивести ключ, двокрапку, а потім елементи
пов'язаного з ним вектору через кому).



\item
Ввести вектор V, елементи якого є англійськими словами. 
Виконати групування елементів ветору V, використовуючи як ключ групувань 
другу літеру елементів (або першу - якщо слова містять лише одну літеру):
В групі повинні входити всі елементи V. Представити результат групування
у вигляді мультивідображення M, ключі якого є ключі
групування (таким чином, відображення M повинно мати тип multimap <char, string>).
Вивести отримане відображення (для кожного елементу відображення
М вивести ключ, а потім пов'язаний з ним елемент вектору V,
 ключи можуть повторюватися).

\item
Ввести вектор дійсних чисел V. У кожній групі його елементів, що мають однакову початкову цифру,
 знайдіть суму значень цих елементів, за виключенням початкового елемента групи (передбачається, що
елементи групи розміщуються в тому же порядку, що і у вихідному
векторі). Якщо група складається з єдиного елемента, то сума
повинна дорівнювати 0. Для кожної групи виводьте відповідну
їй цифру і знайдену суму, впорядкуйте пари по зростанню цифр, а потім суми. 

\item
Послідовність даних в текстовому файлі містить відомості про клієнтів
клубу. Кожний елемент послідовності включає наступні
дуючі цілі поля:<Код клієнту> <Рік> <Номер місяця> <Кількість занять (у годинах)>
Знайти елемент послідовності з мінімальною тривалістю занять.
 Виведіть цю інформацію, а також відповідний рік і номер місяця 
(у вказаному порядку в тому ж рядку).
Якщо таких елементів декілька --- виведіть усі в довільному порядку.

\item
Послідовність даних у бінарному файлі містить відомості про оцінки
учнів з трьох предметів: алгебра, геометрія та інформатика.
Кожен елемент послідовності містить дані про одну
оцінку та має наступні поля:
<Прізвище> <Ініціали> <Клас> <Назва предмета> <Оцінка>. 
Повних тезок (з однаковим прізвищем та ініціалами)
серед учнів немає. Клас задається цілим числом, оцінка - цілим
числом в діапазоні 1–12. Назва предмету вказується з заголовної
літери. Для кожного учня визначити середню оцінку по кожному з предметів і
 вивести її з двома знаками після крапки (якщо не має жодної оцінки, то вивести
 для цього предмету 0.0). Відомості про кожного учня виводити
на окремому рядку, вказавши прізвище, ініціали та середні оцінки
по алгебрі, геометрії та інформатиці. Дані розмістити в алфавітному порядку
прізвищ та ініціалів. 

\item
Реалізувати красиве виведення для всіх асоціативних контейнерів STL
(map, set, multimap, multiset) за допомогою стандартного виведення, 
тобто потрібно перевантажити функцію std::operator \textless{}\textless{} 
для відповідних типів. Приклад виклику: 
\begin{verbatim}
...
std::set<int> testSet{1,3};
std::map<int, std::string> testMap;
testMap[1] = "123";
testMap[2] = "456";
std::cout << testMap;
std::cout << testSet;
...
\end{verbatim}
Вихідні дані (текстовий файл/виведення в консоль):

1=123; 2=456\\
1,3
\end{enumerate}

\section{Додаткові задачі:}
\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{22}

\item
Необхідно реалізувати Proxy (заступник) для контейнера map, що керує доступом.
Реалізувати надбудову над стандартним контейнером map, яка дозволяла б управляти доступом до певних ключів 
(з розмежуванням читання, запису та видалення), а також підміняти при необхідності результати.

У цій системі є три класи:
\begin{itemize}
\item
    std :: map - базовий контейнер;
\item
    Auditor - базовий клас «аудитора», який реалізує перевірку прав і заміну значень;
\item
    ProxiedMap - надбудова над контейнером, яка все операції з ним передує викликом об'єкта Auditor.
\end{itemize}
Реалізувати декілька підкласів для Auditor (той що все дозволяє, що дозволяє читання та підміняє значення по заданих ключами 
константних значеннях і т.д.)

Розробити набір тестів, що перевіряє чи дійсно блокуються спроби несанкціонованого доступу (для різних об'єктів класу Auditor).
Можливе ускладнення:
Реалізувати декілька видів ітераторів (наприклад: ітератор, що обходить всі доступні ключі; 
ітератор, що обходить всі ключі, але сигналізує про помилку доступу при спробі звернення і т.д.) 

\end{enumerate}


\end{document}
