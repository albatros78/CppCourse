\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}


\usepackage[utf8]{inputenc}
\usepackage[english,russian,ukrainian]{babel}

\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\date{}


\usepackage{enumitem}
\makeatletter
\newcommand{\xslalph}[1]{\expandafter\@xslalph\csname c@#1\endcsname}
\newcommand{\@xslalph}[1]{%
    \ifcase#1\or а\or б\or в\or г\or д\or e\or є\or ж\or з\or i%
    \or й\or к\or л\or м\or н\or о\or п\or р\or с\or т%
    \or у\or ф\or х\or ц\or ч\or ш\or ю\or я\or аа\or бб\or вв%
    \else\@ctrerr\fi%
}
\AddEnumerateCounter{\xslalph}{\@xslalph}{m}
\makeatother


\begin{document}


\newpage
\subsection{19. Стандартна бібліотека С++. Асоціативні контейнери.}
\setcounter{subsection}{1}

\begin{itemize}
\item
Які типи ітераторів існують в STL? Які з них визначені для вектору? Які
до списку? Які для множини?
\item
Які асоціативні контейнери існують в Сі++? Що додає приставка multi до
назви контейнера?
\item
Для яких стандартних класів-шаблонів не визначений метод push\_back()?
Чому? Як в ці класи додаються елементи?
\item
Для яких стандартних класів-шаблонів не визначений метод push\_back()?
Чому? Як в ці класи додаються елементи?
\item
Як визначити кількість елементів будь-якого контейнеру?
\item
Які коректні шляхи ітерації по вектору? Мультивідображенню? Будь-якому
контейнеру?
\item
Як коректно пройти по всім елементам відображення?
\end{itemize}

Задачі для аудиторної роботи

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  Заданий файл з текстом англійською мовою. Виділити все різні слова.
  Для кожного слова підрахувати частоту його входження. Слова, що
  відрізняються регістром літер, вважати різними. Використовувати Map.
\item
  Введіть відображення в якому ключ --- це слово, а значення декілька
  слів, які визначають це слово. При цьому порочного кола немає.
  Пронумеруйте слова таким чином, щоб слова з більшим номером
  визначались лише словами з меншими номерами.
\item
  З використанням Set виконати попарне підсумовування довільного
  кінцевого ряду чисел за такими правилами: на першому етапі
  підсумовуються попарно сусідні числа, на другому етапі підсумовуються
  результати першого етапу і т. д. до тих пір, поки не залишиться одне
  число.
\end{enumerate}

Задачі для самостійної роботи

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{3}
\item
  На площині задано N точок. Вивести в файл описи всіх прямих, які
  проходять більш ніж через одну точку із заданих. Для кожної прямий
  вказати, через скільки точок вона проходить. Використовувати клас
  MultiMap.
\item
  На площині задано N відрізків. Знайти точку перетину двох відрізків,
  що має мінімальну абсцису. Використовувати клас Map.
\item
  На клітковому аркуші паперу зафарбована частина клітин. Виділити все
  різні фігури, які утворилися при цьому. Фігурою вважається набір
  зафарбованих клітин, які сусідні один з одного при руху в чотирьох
  напрямах. Дві фігури є різними, якщо їх не можна сумістити поворотом
  на кут, кратний 90 градусам, і паралельним переносом. Використовуйте
  клас MultiSet.
\item
  Нехай значення функції f(n)- кількість літер у письмовому
  представленні числа n (f(1)=4 („один``), f(3)=3(«три»), f(42)=8
  («сорок два», а(2001) =13 («дві тисячи один»))). Знайдіть всі числа до
  10000, для яких f(n) = n. (Вказівка: Використовуйте
  відображення(словник) для зберігання кількості літер у представленні
  цифри)

\item
  Напишіть програму, яка знаходить усі спільні слова між двома вхідними
  файлами, використовуючи set\_intersection (). Змініть його, щоб
  показати слова, які не є спільними, за допомогою
  set\_symmetric\_difference ().

\item
З бінарного файлу зчитати вектор V0, ціле число N (> 0) і набір векторів
V 1, ..., V N.  Знайти кількість векторів V I,
I = 1, ..., N, в яких містяться всі елементи вектору V0 (з урахуванням повторень). 
Використати алгоритм include.

\item
З консолі введений рядок та вектор символів V. 
Знайдіть усі різні числа, які одночасно входять
і в першу, і в другу половині вектору, і записати їх 
у текстовому файлі з заданим імям у порядку заданому вектором, додаючи
після кожного числа символ пробела (використати set\_intersection).
\item
Даний рядок name і вектор V з парною кількістю цілих елементів.
 Знайдіть усі різні числа, які входять у другу половину
вектору та при цьому відсутні в першій половині. Записати 
ці числа в текстовому файлі з ім'ям name за зростанням,
виводиться кожне число на новій строці. Використовувати алгоритм set\_difference.
\item
Ввведать з консолі вектори рядків V 1 і V 2. Знайти всі числа (з урахуванням повторень),
 які входять хоча в один із вихідних векторів, і вивести їх
в порядку незростанння; при цьому, якщо, наприклад, деякий рядок
входить в один із векторів 3 рази, а в іншій 5 разів, то його надо вивести 5 раз.
Використовувати алгоритм set\_union.
\item
Ввести з текстового файлу вектор V, що містить не менше трьох різних чисел.
Виведіть усі його різні елементи, крім максимального та мінімального, 
в порядку спадання за допомогою допоміжної множини та без неї.

\item
Вввести вектор V, елементи якого є англійськими словами. Визначити суммарну довжину
слов, що починається з однієї і тієї же літери (без урахування рагістру),
 і вивести всі різні літери, з яких починаються елементи вектору V, разом із суммар-
ною кількості цих елементів (у алфавітному порядку букв); довжину виводити зразу 
після відповідної букви. Використовувати допоміжне відображення M, ключі якого є початковими буквами
 елементами вектору V, а значення - суммарна кількість цих елементів. 
При заповненні відображения М не використовувати умовні конструкції.

\item
Ввести вектор цілих чисел V. Виконати групування элементов векто-
ра V, використовуючи у якості ключу груп останню (тобто праву) 
цифру елементу: в одній групі повинні входити всі елементи V,
що закінчуються онією цифрою (згруповані 
елементи повинні розташовуватися в тому же порядку, в якому вони
доступні у векторі). Представити результат групування у вигляді відображення M, 
ключі яких є ключі групування, а значення - вектори, що містять згрупованих
елементів (таким чином, відображення М повинно мати тип
map <int, vector <int>>). Вивести отримане отображення (для кожного
елемента відображення M спочатку вивести ключ, двокрапку, а потім елементи
пов'язаного з ним вектору через кому).

\item
Ввести вектор V, елементи якого є англійськими словами. 
Виконати групування елементів ветору V, використовуючи як ключ групувань 
другу літеру елементу (або першу - якщо слов із однієї літери):
в одній групі повинні входити всі елементи V. Представити результат групування
у вигляді мультивідображення M, ключі якого є ключі
групування (таким чином, відображення M повинно мати тип multimap <char, string>).
Вивести отримане отображення (для кожного елемента відображення
М вивести ключ, а потім пов'язаний з ним елемент вік-
тору V, ключи можуть повторюватися).

\item
Ввести вектор дійсних чисел В. У кожній групі його елементів, що мають однакову початкову цифру,
 знайдіть сумму значень цих елементів, за виключенням початкового елемента групи (передбачається, що
елементи групи розміщуються в тому же порядку, що і у вихідному
векторі). Якщо група є з єдиного елемента, то сума
повинна дорівнювати 0. Для кожної групи виводьте відповідну
їй цифру і знайденну сумму, впорядкуйте пари по зростанню цифр. 

\item
Послідовність даних в текстовому файлі містить відомості про клієнтів
фітнес-центра. Каждий елемент послідовності включає наступні
дуючі цілі поля:<Код клієнта> <Год> <Номер месяца> <Кількість занятть (у годинах)>
Знайти елемент послідовності з мінімальною тривалістю занять.
 Виведіть цю інформацію, а також відповідні й рік і номер місяця 
(у вказаному порядку в тому ж рядку).
Якщо таких елементів декілька --- виведіть усі в довільному порядку.

\item
Послідовність даних у бінарному файлі містить відомості про оцінки
учнів за трьом предметами: алгебре, геометрії та інформатика.
Кожний елемент послідовності містить дані про одну
оцінку та має наступні поля:
<Фамилия> <Ініціали> <Клас> <Назва предмета> <Оцінка>. 
Повних однофамільців (із спільною фамілією та ініціалами)
серед учнів немає. Клас задається цілим числом, оцінка - цілим
числом в діапазоні 1–12. Назва предмета вказується з заголовною
літери. Для кожного учня визначити середню оцінку по кожному з предметів і
 вивести її з двома знаками після крапки (якщо не має жодної оцінки, то вивес-
ти для цього предмету 0,00). Відомості про кожного учня виводити
на окремому рядку, вказавши прізвище, ініціали та середні оцінки
по алгебрі, геометрії та інформатиці. Дані розмістити в алфавітному порядку
прізвищ та ініціалов. 

\item
Реалізувати красиве виведення для всіх асоціативних контейнерів STL
( map, set, multimap, multiset) за допомогою стандартного виведення, 
тобто потрібно перевантажити функцію std::operator \textless{}\textless{} 
для відповідних типів. Приклад виклику: 
\begin{verbatim}
...
std::set<int> testSet{1,3};
std::map<int, std::string> testMap;
testMap[1] = "123";
testMap[2] = "456";
std::cout << testMap;
std::cout << testSet;
...
\end{verbatim}
Вихідні дані (текстовий файл/ввиведення в консоль):

1=123; 2=456\\
1,3
\end{enumerate}

Додаткові задачі:
\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{20}

\item
  Ввести натуральне число \(d > 1\) та натуральне число $m$. Знайдіть
  мінімальну кількість натуральних чисел вигляду \(x^{d}\ \)(\(d\)-ступенів
  натуральних чисел) сума яких дорівнює $m$.

\item
Розробити функцію, що читає конфігурацію з текстового файлу.
Конфігураційний файл --- текстовий файл, де строки мають формат значення ключа.
І ключ, і значення є рядками:
\begin{verbatim} 
name foo
value 20
\end{verbatim}
Зайві пробіли ігноруються, також можливі порожні рядки:
\begin{verbatim}
     name           foo

value                  20
\end{verbatim}
Можливі коментарі:
\begin{verbatim}
foo 200 # 400
#bar 400
\end{verbatim}
Всі символи, починаючі з \# ігноруються.

Для задання пробілів у рядках можна використати лапки:
\begin{verbatim}
name " Vasya Pupkin "   # пробіли на початку та в кінці рядку
spaces '     '  # тут 5 пробілів
\end{verbatim}
Рядки, що містять ' та ", записуються так:
\begin{verbatim}
double_quote   '"'
single_quote "'"
both_quotes "'\""
\end{verbatim}
Обратна коса лінія \ має роль escape-символу (аналогично Cі) та дозволяє задавати наступні спецсимволи
 (всередині лапок "…" или '…'):
\begin{verbatim}
    \' – одиночні лапки;
    \" – двойні лапки;
    \n – символ переводу рядку (ASCII-код 10);
    \t – символ табуляції (ASCII-код 9).
    \\ — символ бекслешу.
\end{verbatim}
Реалізувати функцію:

map<string, string> readConfiguration(istream \&is,
                                      string *perrors = nullptr);

яка б читала конфігураційний файл з вхідного потоку і повертала його значення в формі map.

Помилки, пов'язані з неправильним синтаксисом, потрібно повертати в рядку за вказівником perrors (якщо він ненульовий). 
При цьому функція все ж повинна повернути те, що змогла розпізнати в файлі.
Тестування

Для функції повинен бути створений повноцінний набір тестів, що охоплює всі синтаксичні можливості конфігураційних файлів. Для тестів зручно користуватися istringstream, щоб задавати вхідні файли прямо в рядках. 

\item
Розробити клас SrtParser, який здійснює розбір і упорядкування субтитрів, прочитаних з файлу в простому форматі SRT.
Вхідні дані
\begin{verbatim}
Файл в форматі SRT. 

1 
00:00:01,000 --> 00:00:05,500
Раз
два
три

2 
00:00:06,000 --> 00:00:09,500
четыре пять

3
00:00:10,000 --> 00:00:15,500
вышел 
зайчик 
погулять

4
00:00:11,000 --> 00:00:19,500
белый зайчик

5
00:00:12,000 --> 00:00:14,500
наглый зайчик

6
00:00:13,000 --> 00:00:16,500
вышел
и ушел

7
00:00:15,000 --> 00:00:17,500
топтун

8
00:00:19,500 --> 00:00:19,600
вот и всё
\end{verbatim}
Задача
Необхідно реалізувати клас, який вичитує субтитри з файлу, і перетворює
 їх в відсортоване за часом набір команд SHOW TEXT \ HIDE TEXT. 
При цьому не гарантується, що у вхідному файлі субтитри будуть в коректному,
 відсортованому за часом порядку. 
Так само допускається наявність у вхідному файлі "звичайних" 
і навіть "вкладених" за часом субтитрів.

Інтерфейс:
 \begin{itemize}
\item 
    read() --- метод приймає в якості вхідного параметра посилання 
 на відкритий потік введення (std :: istream \&);
\item 
    organize() --- метод впорядковує субтитри за часом показу, 
розбиває "звичайні" і "вкладені одна в одну" субтитри і повертає результат
у вигляді std :: vector <std :: pair <double, std :: string>>.
\end{itemize}

Необхідно реалізувати набір тестів, перевіряючих роботу класу SrtParser. Зокрема необхідно перевірити коректність методів читання та впорядкування субтитрів для ряду окремих випадків:
\begin{itemize}
\item
    некоректні номери записів,
\item
    некоректні часи показу / приховування,
\item
    відсутність в кінці файлу 2 порожніх рядків,
\item
    перетин часів показу двох і більше записів (звернути увагу на порядок об'єднання рядків),
\item
    "Вкладеність" часів показу двох і більше записів,
\end{itemize}
і інші випадки. 
\begin{verbatim}
at 1,00 show 'Раз
два
три'
at 5,50 show ''
at 6,00 show 'четыре пять'
at 9,50 show ''
at 10,00 show 'вышел
зайчик
погулять'
at 11,00 show 'вышел
зайчик
погулять
белый зайчик'
at 12,00 show 'вышел
зайчик
погулять
белый зайчик
наглый зайчик'
at 13,00 show 'вышел
зайчик
погулять
белый зайчик
наглый зайчик
вышел
и ушел'
at 14,50 show 'вышел
зайчик
погулять
белый зайчик
вышел
и ушел'
at 15,00 show 'вышел
зайчик
погулять
белый зайчик
вышел
и ушел
топтун'
at 15,50 show 'белый зайчик
вышел
и ушел
топтун'
at 16,50 show 'белый зайчик
топтун'
at 17,50 show 'белый зайчик'
at 19,50 show 'вот и всё'
at 19,60 show ''
\end{verbatim}

\item
Завдання «Map Proxy»

Необхідно реалізувати Proxy (заступник) для контейнера map, керуючий доступом.
Реалізувати надбудову над стандартним контейнером map, яка дозволяла б управляти доступом до певним ключам (з розмежуванням читання, записи і видалення), а також підміняти при необхідності результати.

У цій системі є три класи:
\begin{itemize}
\item
    std :: map - базовий контейнер.
\item
    Auditor - базовий клас «аудитора», який реалізує перевірку прав і заміну значень.
\item
    ProxiedMap - надбудова над контейнером, яка все операції з ним передує викликом об'єкта Auditor.
\end{itemize}
Реалізувати кілька підкласів для Auditor (все дозволяє, що дозволяє читання та підміняє значення по заданих ключам 
константні значення і т.д.)
Тестування

Розробити набір тестів, перевіряючий, чи дійсно блокуються спроби несанкціонованого доступу (для різних Auditor).
Можливе ускладнення:
Реалізувати декілька видів ітераторів (наприклад: ітератор, що обходить всі доступні ключі; 
ітератор, що обходить всі ключі, але сигналізує про помилку доступу при спробі звернення і т.д.) 



\end{enumerate}


\end{document}
