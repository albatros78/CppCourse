\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}


\usepackage[utf8]{inputenc}
\usepackage[english,russian,ukrainian]{babel}

\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\date{}


\usepackage{enumitem}
\makeatletter
\newcommand{\xslalph}[1]{\expandafter\@xslalph\csname c@#1\endcsname}
\newcommand{\@xslalph}[1]{%
    \ifcase#1\or а\or б\or в\or г\or д\or e\or є\or ж\or з\or i%
    \or й\or к\or л\or м\or н\or о\or п\or р\or с\or т%
    \or у\or ф\or х\or ц\or ч\or ш\or ю\or я\or аа\or бб\or вв%
    \else\@ctrerr\fi%
}
\AddEnumerateCounter{\xslalph}{\@xslalph}{m}
\makeatother


\begin{document}


\newpage
\subsection{20. Стандартна бібліотека С++. Алгоритми та функтори.}
\setcounter{subsection}{1}



\begin{itemize}

\item
  Які існують бібліотеки алгоритмів в STL?
\item
  Як скористатись алгоритмами сортування? Акумульованої суми? Пошуку?
\item
  Як знайти потрібний елемент в будь-якому контейнері за допомогою
  стандартних алгоритмів?
\item
  Що таке придикат та функтор? Як ними скористатись?
\item
  Як відсортувати вектор по незростанню? Неспаданню?
\item
  Коли і як можна скористатись бінарним пошуком в колекції?
\item
  Як за допомогою алгоритмів знайти суму масиву одним викликом функції?
  А як норму вектору двома викликами за допомогою функтору?
\end{itemize}

Задачі для аудиторної роботи

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}

\item
Построїть клас Булеввектор (BoolVector). 
Реалізувати методи для виконання порозрядних кон'юнкції, диз'юнкції і 
заперечення векторів, а також підрахунку числа одиниць і нулів у векторі.
  
\item
  Створить список цілих чисел List і число X. Не використовуючи
  допоміжних об'єктів і не змінюючи розміру списку, переставити елементи
  списку так, щоб спочатку йшли числа, що не перевищують X, а потім
  числа що є більшими за X.

\item
  У файлі записані координати точок на площині задані парою цілих чисел.
  Точки записуються в форматі : ( х1 , х2 ) (х1 , х2) , \ldots{} - саме
  так через коми та дужки. Створити файл, в якому будуть записані
  координати всіх відрізків з точок цього файлу, при цьому ці відрізки
  відсортовані за зростанням довжини.
\item
  Напишіть функцію, як повертає а) суму найбільших k чисел даного
  вектору, б) масив з k найменших чисел даного вектору, якщо k не
  перевищує розмір масиву та а) нуль б) порожній масив в протилежному
  випадку.
\item
  Створіть генератор, який повертає поточне значення clock () (у
  \textless{}ctime\textgreater{}). Створіть список
  \textless{}clock\_t\textgreater{} і заповніть його своїм генератором
  за допомогою create\_n (). Видаліть усі дублікати зі списку та
  роздрукуйте його на cout за допомогою copy ().
\item
  За допомогою transform () і toupper () (у
  \textless{}cctype\textgreater{}) напишіть один виклик функції, який
  перетворить рядок на всі великі літери.
\item
  Створіть шаблон об'єкта функції Sum, який буде накопичувати всі
  значення в діапазоні при використанні з for\_each ().
\item
  Напишіть генератор анаграм, який приймає слово як аргумент командного
  рядка і створює всі можливі перестановки літер.
\item
  Напишіть генератор анаграм речень, який приймає речення як аргумент
  командного рядка і створює всі можливі перестановки слів у реченні.
  (Це залишає слова в спокої і просто рухає їх навколо).
\end{enumerate}

Задачі для самостійної роботи

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{9}
\item
  У файлі записані координати Точок в просторі задані трійкою цілих
  чисел. Точки записуються в форматі : х1 , х2 , х3 ; х1 , х2, х3 ;
  \ldots{} . Створити файл, в якому будуть записані відрізки з точок цього файлу, при
цьому ці відрізки відсортовані за зростанням довжини.

\item
  Армія хоче набрати людей зі свого виборчого списку служб. Вони
  вирішили набрати тих, кому менше 35 років, починаючи
  від найстаршого і закінчуючи наймолодшим. Згенеруйте довільну кількість
  людей. Надайте їм такі дані, як вік та прізвища записані як вектор.
  Розділіть вектор так, щоб ті, кому менше 35 років, були
  упорядковані на початку списку, починаючи від наймолодшого до
  найстаршого, а решту частину списку залишали відсортувати за прізвищем.

\item
  Напишіть програму, яка знаходить усі спільні слова між двома вхідними
  файлами, використовуючи set\_intersection (). Змініть його, щоб
  показати слова, які не є спільними, за допомогою
  set\_symmetric\_difference ().

\item
  У файлі записані координати Точок на площині задані парою цілих чисел
  та масою(дійсне число). Точки записуються в форматі : (х1 , х2): m1 ,
  (х1 , х2): m2 , \ldots{} Створити файл, в якому будуть записані
  відрізки з точок цього файлу, при цьому ці точки відсортовані за
  важилем сили (m1*(х1 +х2)).
\item
  У файлі записані дати , що трійкою цілих чисел у форматі: чч/мм/рр,
  \ldots{} Створити файл, в якому будуть записані дати з цього файлу без
  повторень, при цьому ці дати відсортовані за спадання дати (врахуйте,
  що роки дат з 1951 по 2049).
\item
  У файлі записані дати , що двома цілими числами та рядком (англійські
  або числові назви місяця) у форматі: чч1 місяць1 рік1, чч2 місяць2
  рік2\ldots{}. Вивести дати без повторень з цього файлу у форматі:
  рік1/місяць1/число1, рік2/місяць1/число2,... (місяць заданий назвою)
  при цьому ці дати відсортовані за зростанням дати
\item
  Створіть ієрархію класів з базовим класом B та похідним класом D.
  Помістіть функцію віртуального члена void f () у B таким чином, щоб
  вона надрукувала повідомлення, що вказує, що було викликано B sf (), і
  перевизначити цю функцію для D щоб надрукувати інше повідомлення.
  Створіть вектор \textless{}B *\textgreater{} і заповніть його
  об'єктами B і D. Використовуйте for\_each () для виклику f () для
  кожного з об'єктів у вашому векторі.
\item
  Створіть програму, яка, отримуючи ціле число в командному рядку,
  створює таблицю факторіалів з усіх факторіалів, включаючи число в
  командному рядку. Для цього напишіть генератор для заповнення вектора
  \textless{}int\textgreater{}, а потім використовуйте partial\_sum() 
зі стандартним об'єктом функтором.
\item
  Використовуючи символи "\textasciitilde{}`! @ \# \$\% \^{} \& * () \_-
  + =\} \{{[}{]} \textbar{} \textbackslash{} :;
  "'\textless{}.\textgreater{},? /", згенеруйте кодову книгу,
  використовуючи вхідний файл, вказаний у командному рядку як словник
  слів. Не турбуйтеся про вилучення не алфавітних символів і не
  турбуйтеся про регістр слів у файлі словника. Співставте кожну
  перестановку рядка символів із таким словом, наприклад:
\begin{verbatim}

"= ') /\% {[}\}{]} \textbar{} \{* @ ?!" `,;\textgreater{} \& \^{} -
\textasciitilde{} \_: \$ +. \# (\textless{}\textbackslash{}" apple ",

\textbar{}{]} \textbackslash{} \textasciitilde{}\textgreater{} \#. +\%
(/ -\_ {[}` ':; =\} \{* "\$ \^{}! \&?), @ \textless{}"carrot ",

@ = \textasciitilde{} {[}'{]}. \textbackslash{} /
\textless{}-`\textgreater{} \# *) \^{}\% +, "; \&?! \_ \{: \textbar{}
\$\} " Carrot'' тощо .
\end{verbatim}
Переконайтеся, що у вашій книзі кодів немає повторюваних кодів або слів.
Використовуйте lexicographic\_compare (), щоб виконати сортування кодів.
Використовуйте книгу кодів для кодування файлу словника. Розшифруйте
своє кодування файлу словника та переконайтеся, що ви повернули той
самий вміст.

\item
  Створіть алгоритм стилю STL transform\_if (), слідуючи першій формі
  transform (), яка виконує перетворення лише на об'єктах, які
  задовольняють одинарний предикат. Об'єкти, які не задовольняють
  предикату, опускаються з результату. Потрібно повернути новий кінцевий
  ітератор.
\item
  Створіть алгоритм стилю STL, який є перевантаженою версією for\_each
  (), але слідує за другою формою trasform() і займає два діапазони
  введення, щоб він міг передавати об'єкти другого діапазону введення a
  двійковій функції, яку він застосовує до кожного об'єкта першого
  діапазону.

\item
  Створіть клас «Місто» з даними про населення, висоту та погоду.
  Зробіть погоду за допомогою перерахування \{ДОЩИТЬ, СНІЖНО, ХМАРНО,
  ЯСНО\}. Створіть клас, який генерує об'єкти Town. Створіть назви міст
  (незалежно від того, мають вони сенс чи ні, це не має значення) або
  витягніть їх з Інтернету. Переконайтеся, що назва всього міста має
  маленькі регістри, а дублікатів назв немає. Для населення, висот та погодних
  полів створіть генератор, який випадковим чином генеруватиме погодні
  умови, популяції в межах {[}100-1000000) та висоти між {[}0, 8000)
  футами. 
\begin{enumerate}[label=\xslalph*)]
\item
Заповніть вектор об'єктами міста. Перепишіть вектор у новий
  файл під назвою Towns.txt. 
 
  \item
 Відбувся бебі-бум, що призвело до збільшення населення на 10\% у кожному
місті. Оновіть дані про місто за допомогою transform (), перепишіть дані
назад у файл. 
\item
Знайдіть міста з найбільшим і найменшим населенням. Для цієї вправи
  застосуйте оператор \textless{}для вашого класу Town. Також спробуйте
  реалізувати функцію, яка повертає true, якщо її перший параметр менше,
  ніж другий. Використовуйте його як предикат для виклику
  використовуваного вами алгоритму.
 \item
Знайдіть усі міста на висоті 2500--3500 футів включно. За необхідності
реалізуйте оператори рівності для класу Town.
 \item
  Нам потрібно розмістити аеропорт на певній висоті, але розташування не
  є проблемою. Впорядкуйте свій список міст так, щоб не було дублікатів
  (дублікат означає, що жодні дві висоти не знаходяться в одному
  діапазоні 100 футів. До таких класів належать {[}100, 199), {[}200,
  199) і т.д. Відсортуйте цей список за зростанням принаймні двома
  різними способами, використовуючи об'єкти функції в
  \textless{}functional\textgreater{}. Зробіть те ж саме для порядку
  зменшення. За необхідності впроваджуйте реляційні оператори для міста.
\end{enumerate}
\item
  Створіть довільну кількість випадкових чисел у масиві на основі стеку.
  Використовуйте max\_element (), щоб знайти найбільше число в масиві.
  Поміняйте його номером у кінці масиву. Знайдіть наступне найбільше
  число та росташуйте його в масиві в позиції перед попереднім числом.
  Продовжуйте це робити, доки всі елементи не будуть переміщені. Коли
  алгоритм буде завершено, ви отримаєте відсортований масив. (Це
  сортування виділенням)
\item
  Напишіть програму, яка знімає телефонні номери з файлу (що також
  містить імена та іншу відповідну інформацію) та змінює номери, що
  починаються з 222 на 863. Обов'язково збережіть старі номери. Формат
  файлу такий:
\begin{verbatim}
222 8945
756 3920
222 8432
\end{verbatim}

Напишіть програму, яка за прізвищем знайде кожного з цим прізвищем із
відповідним номером телефону. Використовуйте алгоритми, які мають справу
з діапазонами (upper\_bound, lower\_bound, equal\_range тощо). Сортуйте
за прізвищем, що діє як первинний ключ, а за іменем, що діє як вторинний
ключ. Припустимо, що ви прочитаєте імена та номери з файлу, формат якого
буде таким. (Обов'язково впорядкуйте їх так, щоб прізвища були
впорядковані, а імена впорядковані в межах прізвищ.):

Джон Доу 345 9483

Нік Бонем 349 2930

Джейн Доу 283 2819

Отримавши файл із даними, подібними до наведених нижче, витягніть із
нього всі державні абревіатури та помістіть їх в окремий файл. (Зверніть
увагу, що ви не можете залежати від номера рядка для типу даних. Дані
містяться на випадкових рядках.)

\item
  Порівняйте роботу функцій sort(), partial\_sort() та nth\_element()
  одну з іншою і з'ясуйте, чи дійсно варто використовувати одне із
  слабких сортувань, коли вони можуть спрацювати коректно.

\end{enumerate}




\end{document}
