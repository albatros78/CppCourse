\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}


\usepackage[utf8]{inputenc}
\usepackage[english,russian,ukrainian]{babel}

\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\date{}


\usepackage{enumitem}
\makeatletter
\newcommand{\xslalph}[1]{\expandafter\@xslalph\csname c@#1\endcsname}
\newcommand{\@xslalph}[1]{%
    \ifcase#1\or а\or б\or в\or г\or д\or e\or є\or ж\or з\or i%
    \or й\or к\or л\or м\or н\or о\or п\or р\or с\or т%
    \or у\or ф\or х\or ц\or ч\or ш\or ю\or я\or аа\or бб\or вв%
    \else\@ctrerr\fi%
}
\AddEnumerateCounter{\xslalph}{\@xslalph}{m}
\makeatother


\begin{document}


\newpage
\subsection{4.1. Робота з бінарними файлами на Сі}
\setcounter{subsection}{1}

Контрольні запитання:
\begin{itemize}
\item
  Цикл роботи з файлами на Сі/Сі++.
\item
  Як створити та працювати з текстовим файлом на Сі? Як можна вводити та
  виводити файл посимвольно? Порядково?
\item
  Чим відрізняється бінарний файл від текстового? 
\item 
  Як створити бінарний файл? Як читати з бінарного файлу?
\item
  Як записати та прочитати масив дійсних чисел в/з бінарного файлу?
\item
  Як прочитати всі цілі числа з файлу, якщо на початку роботи невідомо,
  скільки їх там насправді?
\item
  Які додаткові речі можна робити з бінарним файлом, що неможна робити з
  текстовим?
\item
  Як записати масив структур у файл та прочитати k-тий запис у файлі?
\end{itemize}

Задачі для аудиторної роботи

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}

\item
  Використовуючи файл F, компоненти якого є дійсними числами, побудувати
  файл G, що містить усі числа з файлу F, які менші по модулю за задане число $a>0$.
  Послідовність чисел зберігається. Після цього видалити всі елементи з файлу F, 
  які менші по модулю за число $a$.

\item
  Дано файл F, компоненти якого є цілими числами. Побудувати файл G,
  який містив би всі компоненти файлу F:
\begin{enumerate}[label=\xslalph*)]
\item
що є парними числами; 
\item
 що діляться на 3 і на 5;
\item
що є точними квадратами; 
\item
що мають лише 3 дільники; 
\item
що є паліндромами;
\item
що є числами Фібоначчі.
\end{enumerate}


\item
  Дано файл, який містить відомості про прямокутники: вказано номер
  прямокутника у файлі, координати (дійсні числа) верхнього лівого кута та
  нижнього правого кута прямокутника. Скласти функцію пошуку
  прямокутника з найбільшою площею й визначення цієї площі.
\item
  Дано файл, компоненти якого є структури $(coef, deg, num )$ -- 
дійсний коефіцієнт, ступінь члену полінома ($koef \ge 0$) та номер поліному. 
Таким чином в файлі записано декілька поліномів (номер поліному встановлює
до якого поліному належить цей член).
Визначити підпрограми для
  виконання таких дій над поліномом:

\begin{enumerate}[label=\xslalph*)]
\item
введення полінома та запис (додавання) його в файл; 
\item
друк полінома з файлу за номером на консоль у звичному вигляді поліному від $x$;
\item
обчислення похідної від полінома за файлом та номером;
\item
додавання поліному у файл заданий іменем;
\item
видалення поліному за даним номером;
\item
заміна коефіцієнту заданого ступенем та номером поліному;
\item
заміна коефіцієнту заданого номером структури у файлі.
\end{enumerate}

\end{enumerate}


Задачі для самостійної роботи

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{4}
\item
  Дано файл, компоненти якого є натуральними числами. Скласти
  підпрограми для обчислення:
\begin{enumerate}[label=\xslalph*)]
\item
кількості парних чисел серед компонент;
\item
кількості квадратів непарних чисел серед компонент;
\item
різниці між найбільшим парним і найменшим непарним числами компонент;
\item
кількості простих чисел серед компонент;
\item  
кількості компонент у найдовшій зростаючій послідовності компонент
файлу.
\end{enumerate}

\item
  Дано файл, компоненти якого є дійсними числами. Скласти підпрограми
  для обчислення:
\begin{enumerate}[label=\xslalph*)]
\item
суми компонент файлу;
\item
кількості від'ємних компонент файлу;
\item
останньої компоненти файлу;
\item
передостанньої компоненти;
\item 
найбільшої по модулю компоненти файлу;
\item
найменшої з компонент файлу з парними номерами;
\item 
суми найбільшої та найменшої з компонент;
\item
різниці першої й останньої компоненти файлу;
\item
кількості компонент файлу, які менші за середнє арифметичне всіх його
компонент.
\end{enumerate}


\item
  Задано натуральне число $n$ та файл F, компоненти якого є цілими
  числами. Побудувати файл G, записавши до нього найбільше значення
  перших $n$ компонент файлу F, потім -- наступних $n$ компонент тощо.
  Розглянути два випадки:
\begin{itemize}
\item
кількість компонент файлу ділиться на $n$;
\item
кількість компонент файлу не ділиться на $n$. 
\end{itemize}
Остання компонента файлу G має дорівнювати найбільшій із компонент 
файлу F, які утворюють останню (неповну) групу.

\item
  Дано файл F, компоненти якого є цілими числами. Файл містить рівну
кільксть додатних і від'ємних чисел -- перевірте це і в противному
  випадку видайтие відповідне повідомлення та не робить нічого.
  Використовуючи допоміжний файл H, переписати компоненти файлу F до
  файлу G так, щоб у файлі G:
\begin{enumerate}[label=\xslalph*)]
\item
не було двох сусідніх чисел одного знаку;
\item
спочатку йшли додатні, потім -- від'ємні числа;
\item
числа йшли таким чином: два додатних, два від'ємних тощо. Якщо це
неможливо -- то переписати поки можливо в такому вигляді, а останні два
числа вивести на консоль.
\end{enumerate}

\item
  Дано файл F, компонентами якого є записи (структури) вигляду
\begin{verbatim}
struct T {
unsigned Key; // ключ
char Data[10]; // дані
};
\end{verbatim}

Такий файл називатимемо впорядкованим за ключами, якщо записи в ньому
розташовуються в порядку зростання (спадання) ключів. Скласти процедуру
пошуку запису за ключем у впорядкованому файлі. Скласти процедуру
вилучення запису із заданим ключем:
\begin{itemize}
\item з впорядкованого файлу;
\item з невпорядкованого файлу.
\end{itemize}

\item
  Багаж пасажира характеризується номером пасажира, кількістю речей і
  їхньою загальною вагою. Дано файл пасажирів, який містить прізвища
  пасажирів, і файл, що містить інформацію про багаж декілька пасажирів
  (номер пасажира -- це номер запису у файлі пасажирів)

  Скласти процедури для:
  \begin{enumerate}[label=\xslalph*)]
\item
знаходження пасажира, у багажі якого середня вага однієї речі
відрізняється не більш ніж на 1 кг від загальної середньої ваги речей;
\item
визначення пасажирів, які мають більше двох речей, і пасажирів
кількість речей у яких більша за середню кількість речей;
\item
видачі відомостей про пасажира, кількість речей у багажі якого не
менша, ніж у будь-якому іншому багажі, а вага речей -- не більша, ніж у
будь-якому іншому багажі із цією самою кількістю речей;
\item
визначення, чи мають принаймні два пасажири багажі, які не
відрізняються за кількістю речей і відрізняються вагою не більш ніж на 1
кг (якщо такі пасажири є, то показати їхні прізвища);
\item визначення пасажира, багаж якого складається з однієї речі вагою не
менше $m$ кг.
  \end{enumerate}

\item
  Дано файл, який містить відомості про іграшки: указано назву іграшки
  (напр., м'яч, лялька, конструктор тощо), її вартість у гривнях і
  вікові межі для дітей, яким іграшка призначається (напр., для дітей
  від двох до п'яти років). Скласти функції, що виводять наступні результати 
  у бінарний файл та на консоль:

  \begin{enumerate}[label=\xslalph*)]
\item
пошуку назв іграшок, вартість яких не перевищує заданої кількості гривень,
 призначених дітям п'яти років;
\item
пошуку назв іграшок, призначені дітям і чотирьох, і десяти років;
\item
пошуку назв найдорожчих іграшок (ціна яких відрізняється від ціни
найдорожчої іграшки не більш ніж на 50 грн);
\item визначення ціни найдорожчого конструктора;
\item визначення ціни всіх кубиків;
\item пошуку двох іграшок, що призначені дітям трьох років, сумарна
вартість яких не перевищує X грн;
\item
пошуку конструктора ціною Y грн, призначеного дітям від п'яти до
десяти років. Якщо такої іграшки немає, то занести відомості про її
відсутність до файлу.
  \end{enumerate} 


\end{enumerate}

Додаткові задачі:

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}s
\setcounter{enumi}{11}
\item
  У двох файлах міститься таблиця футбольного турніру, у першому --
  записано назви команд; у другому -- результати матчів, що зберігаються
  у записах типу T\_Match:
\begin{verbatim}
typedef struct {
unsigned int n1, n2;
unsigned int b1, b2;
} T_Match;
\end{verbatim}
Тут у структурі типу T\_Match поля n1, n2 -- номери першої і другої 
команд (тобто номери назв команд у файлі команд); b1, b2 -- кількість
м'ячів, забитих першою та другою командами, відповідно.
Кожній команді за перемогу нараховується 3 очки, за нічию -- 1, за
поразку -- 0.
Із двох команд, які мають однакову кількість очок, першою вважається:
\begin{itemize}
\item
та, що має кращу різницю забитих і пропущених м'ячів;
\item
за однакової різниці має більше забитих м'ячів;
\item
за всіма однаковими попередніми показниками визначається жеребкуванням
(для жеребкування використати генератор випадкових чисел).
\end{itemize}
Знайти команду, яка є лідером.

\emph{Вказівка.} Описати підпрограми створення файлів команд і матчів, 
додавання результату матчу, визначення лідера.

\item
Файл бази даних з малюнками містить на початку ціле 32-бітне число
2051, потім ціле 32-бітне число $K$ --- кількість малюнків, а наступні два
32-бітних числа $n,m$ --- висота та ширина кожного малюнку у
пікселах. При цьому ці числа задані в форматі big-indian.
Наступний вміст файлу -- беззнакові натуральні байти ($K*n*m$ байтів),
кожен з яких -- значення яскравостей пікселів (число від 0 до 255)
кожного з цих малюнків, що проходяться у порядку зліва-направо та
згору-донизу.

Напишіть функцію, що перевіряє даний файл (заданий ім'ям) на
відповідність даному формату та виводить масив яскравостей малюнка з
заданим номером, якщо такий номер та сам файл коректно задані. В
противному випадку вивести змістовне повідомлення про помилку.

\end{enumerate}

\end{document}
